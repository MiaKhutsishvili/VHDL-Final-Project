library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use work.Packages.ALL;

entity ControlUnit is
    Port (
        InByte     : in  byte;              -- 8-bit input
        Switch     : out STD_LOGIC;         -- 0: RAM / 1: ALU
        Packet     : out data_packet;       -- output packet
        PackMode   : out packet_type;
        Validation : out STD_LOGIC;
        clk        : in  STD_LOGIC;
        RST        : in  STD_LOGIC
    );
end ControlUnit;

architecture Behavioral of ControlUnit is
    -- Packet buffer (7 bytes), decoded type, and byte index
    signal PackHold : data_packet := (others => (others => '0'));
    signal PackType : packet_type := zero;
    signal step     : integer range 0 to 7 := 0;  -- 0..6 bytes, 7 = DONE (hold)

begin
    process (clk)
        -- Local variables used within a single clock to avoid signal update latency
        variable pack_v : data_packet;
        variable mode_v : packet_type;
    begin
        if rising_edge(clk) then
            if RST = '1' then
                -- Synchronous reset
                step       <= 0;
                PackHold   <= (others => (others => '0'));
                PackType   <= zero;

                Packet     <= (others => (others => '0'));
                PackMode   <= zero;
                Switch     <= '0';
                Validation <= '0';

            else
                case step is
                    ----------------------------------------------------------------
                    -- STEP 0: capture header byte and classify packet
                    ----------------------------------------------------------------
                    when 0 =>
                        -- start a new packet
                        PackHold       <= (others => (others => '0'));
                        PackHold(0)    <= InByte;
                        Validation     <= '0';      -- clear valid at the *start* of a new packet

                        -- decode type from header (InByte just captured)
                        case InByte is
                            when "00000000" | "00000001" | "00000010" | "00000011" =>
                                PackType <= Operand_Alu;
                            when "11110000" =>
                                PackType <= Writ_e;
                            when "00001111" =>
                                PackType <= Rea_d;
                            when "00111100" | "00111101" | "00111110" | "00111111" =>
                                PackType <= Immediate_Alu;
                            when "11000000" | "11000001" | "11000010" | "11000011" =>
                                PackType <= Array_Alu;
                            when "00110000" | "00110001" | "00110010" | "00110011" =>
                                PackType <= Indirect_Addressing;
                            when others =>
                                PackType <= zero;
                        end case;

                        step <= 1;

                    ----------------------------------------------------------------
                    -- STEPS 1..5: capture subsequent bytes, with early jumps
                    ----------------------------------------------------------------
                    when 1 =>
                        PackHold(1) <= InByte;
                        -- For Read, only 2 payload bytes before checksums
                        if PackType = Rea_d then
                            step <= 4;             -- jump to checksum bytes
                        else
                            step <= 2;
                        end if;

                    when 2 =>
                        PackHold(2) <= InByte;
                        -- For Write, only 3 payload bytes before checksums
                        if PackType = Writ_e then
                            step <= 4;
                        else
                            step <= 3;
                        end if;

                    when 3 =>
                        PackHold(3) <= InByte;
                        -- For Operand/Immediate/Indirect, we can move to checksums now
                        if (PackType = Operand_Alu) or (PackType = Immediate_Alu) or (PackType = Indirect_Addressing) then
                            step <= 4;
                        else
                            step <= 4;  -- for Array_Alu we still take bytes 4..6 as usual
                        end if;

                    when 4 =>
                        PackHold(4) <= InByte;
                        step <= 5;

                    when 5 =>
                        PackHold(5) <= InByte;     -- expected CheckSumH
                        step <= 6;

                    ----------------------------------------------------------------
                    -- STEP 6: last byte arrives -> validate & publish NOW, then go to DONE
                    ----------------------------------------------------------------
                    when 6 =>
                        PackHold(6) <= InByte;     -- expected CheckSumL
                        pack_v := PackHold;
                        pack_v(6) := InByte;
                        mode_v   := PackType;      
                        Packet   <= pack_v;
                        PackMode <= mode_v;
                        Validation <= Validate(pack_v);
                        if (mode_v = Writ_e) or (mode_v = Rea_d) or (mode_v = zero) then
                            Switch <= '0';         -- RAM path
                        else
                            Switch <= '1';         -- ALU path
                        end if;
                        step <= 7;

                    ----------------------------------------------------------------
                    -- STEP 7 (DONE): hold current outputs for one full cycle
                    ----------------------------------------------------------------
                    when 7 =>
                        step <= 0;

                    when others =>
                        step <= 0;
                end case;

            end if;
        end if;
    end process;

end Behavioral;
